---
title: Without Throw
description: Convert throwing functions into data/error tuples.
---

## withoutThrow

```ts twoslash
import { withoutThrow } from '@moeru/std/without-throw'

const safeJSONParse = withoutThrow((text: string) => JSON.parse(text))

const result = safeJSONParse('{"hello":"world"}')

if (result.error)
  console.error('Failed to parse JSON', result.error)
else
  console.log(result.data.hello)
```

### specify error type

```ts twoslash
import { withoutThrow } from '@moeru/std/without-throw'

const safeJSONParse = withoutThrow<typeof JSON.parse, SyntaxError>(JSON.parse)

const result = safeJSONParse('invalid')

if (result.error)
  result.error satisfies SyntaxError // [!code highlight]
```

## withoutThrowAsync

```ts twoslash
import { withoutThrowAsync } from '@moeru/std/without-throw'

const fetchJSON = withoutThrowAsync(async (url: string) => {
  const res = await fetch(url)
  if (!res.ok)
    throw new Error(res.statusText)
  return res.json()
})

const result = await fetchJSON('https://example.com/data.json')

if (result.error)
  console.error('Request failed', result.error)
else
  console.log(result.data)
```

## Remarks

This wrapper keeps your call sites non-throwing and therefore easier to compose. It is a lightweight alternative to result librariesâ€”if you need richer ergonomics (matching, chaining, etc.) consider adopting a full Result/Try monad.
